网络编程

外部网络当作一个文件处理（linux"万物皆可文件"），通过相应的文件描述符进行写与读
服务器：socket产生一个不完全打开的文件描述符---> bind将描述符与服务器主机绑定--->listen将描述符改为监听描述符--->Accept已连接描述符，现在可以通过描述符进行读写响应
客户端：socket产生一个不完全打开的文件描述符--->connect连接服务器（或代理服务器），通过描述符读写发送请求

简单迭代服务器：一次处理一个请求
并发服务器：可以同时处理多个请求

并发的实现
基于进程，每次来一个请求，就创建一个新的进程来处理，记得在父进程关掉对应描述符，子进程关掉监听描述符
基于IO多路复用，通过select来确定是什么请求，比较麻烦
基于线程：每次来一个请求，创建一个线程例程去处理，由内核切换，由于共享变量的问题，引入信号量

互斥锁：实现对共享变量的互斥访问，又称二元信号量
计数信号量:一个被用作一组可用资源的计数器信号量

生产者---消费者模型： 提前创建几个例程，可以避免每次来一个请求创建一个线程例程的消耗
读者---写者模型

死锁：避免方法，按照一定的顺序请求

Proxy lab
代理服务器---
作为中间人接收来自客户端的请求，因此要具备监听的功能
之后作为客户端将接收到的信息经过修改发送给终端服务器，因此要连接远程终端
最后将终端服务器发回的响应发回客户端即可。

可以开两个terminal界面，一个用来创建代理服务器，一个用作客户端

代理服务器：./proxy 端口号
客户端：telnet locolhost 端口号
GET http://www....... HTTP/1.1
端口号必须大于1000， 可以通过port_for_user.pl得到，记得一定要发Host报头

第一部分抄一下书上相应实现即可
第二部分并发，对每一个到达的请求创建一个线程例程
第三部分：建一个共享全局数组，编写对应的读写函数，由信号量保护，若是缓存命中，则直接返回响应给客户端，若不是，则从终端获取返回，并更新缓存
这里为简单起见，采用了读者优先策略

最后./driver.sh运行查看最终结果即可（缺什么补什么，比如curl、netstat）
（忘了说了，通过telnet运行时比如小米或者华为的官网，通过telnet还是能获取到的，但是像百度、腾讯。。。始终出现Moved permanently，很是不解，而且将这个设置为火狐的代理，好像也不行
可能有什么触及到了自己的知识点盲区，以后再理解吧）

cmu csapp的lab到这就暂时告一段落了，完结撒花（哈哈哈）。
